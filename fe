import networkx as nx
import heapq
import random

def temps_attente(cycle, t):
    """Calcule le temps d'attente au feu selon l'heure t et son cycle (vert, rouge)."""
    vert, rouge = cycle
    periode = vert + rouge
    t_mod = t % periode
    if t_mod < vert:
        return 0  # vert
    else:
        return periode - t_mod  # attente jusqu'au prochain vert

def creer_ville(nb_noeuds, proba_route=0.3):
    """Crée une ville simple avec des routes et des feux rouges."""
    G = nx.DiGraph()
    cycles = {}
    for i in range(nb_noeuds):
        # chaque noeud a un cycle aléatoire vert/rouge

        cycles[i] = (random.randint(5, 15), random.randint(10, 30))
        G.add_node(i)
        cycles[i] = (random.randint(5, 15), random.randint(10, 30))# possibilité de modifier le random des cycles 
        G.add_node(i)
        #cree les routes 
        for u in range(nb_noeuds):
            for v in range(nb_noeuds):
                if u != v and random.random() < proba_route:
                   G.add_edge(u, v, weight=random.randint(1, 10) #mettre le poids des feux)
        return G,cycles

def dijkstra_dynamique(G, cycles, depart, arrivee):
    """Dijkstra qui tient compte du temps d’attente aux feux rouges."""
    file = [(0, depart, [depart])]
    vus = {}
    while file:
        temps, noeud, chemin = heapq.heappop(file)
        if noeud == arrivee:
            return temps, chemin
        if noeud in vus and vus[noeud] <= temps:
            continue
        vus[noeud] = temps
        for voisin in G.successors(noeud):
            poids = G[noeud][voisin]["weight"]
            t_arr = temps + poids
            attente = temps_attente(cycles[voisin], t_arr)
            nouveau_temps = t_arr + attente
            heapq.heappush(file, (nouveau_temps, voisin, chemin + [voisin]))
    return float("inf"), []


# partie animation 
def anime_ville(G, cycles, duree=50):
    pos = nx.spring_layout(G, seed=42)

    fig, ax = plt.subplots(figsize=(6, 6)) #taille 6*6

    def update(t): #temps courant
        ax.clear() #enleve le graphe précedent
        couleurs = []
        labels = {}
        for n in G.nodes():
            cycle = cycles[n]
            attente = temps_attente(cycle, t) #check les cycles
            if attente == 0:
                couleurs.append("green")
            else:
                couleurs.append("red")
            labels[n] = f"{n}\n({cycle[0]},{cycle[1]})" #dessine la couleur et le cycle
        nx.draw(G, pos, ax=ax, with_labels=True, node_color=couleurs,
                labels=labels, node_size=1000, font_color="white")
        nx.draw_networkx_edge_labels(G, pos, edge_labels=nx.get_edge_attributes(G, "weight"))
        ax.set_title(f"Temps = {t}")
        
        if chemin:
            # déterminer la position approximative de la voiture
            idx = min(t // 2, len(chemin) - 1)  # avance tous les 2 "temps"
            current_node = chemin[idx]
            ax.scatter(*pos[current_node], c="blue", s=300, marker="o", edgecolors="black", zorder=3, label="Voiture")

        ax.set_title(f"Temps = {t}")
    ani = animation.FuncAnimation(fig, update, frames=duree, interval=500, repeat=False) #animation trucs
    plt.show() 

#Exqimarchebien
G, cycles = creer_ville(8, 0.3)
depart, arrivee = 0, 5
temps, chemin = dijkstra_dynamique(G, cycles, depart, arrivee)
print(f"Chemin trouvé : {chemin} en {temps} secondes")

anime_ville(G, cycles, chemin, duree=40)
