import networkx as nx
import heapq
import random

def temps_attente(cycle, t):
    """Calcule le temps d'attente au feu selon l'heure t et son cycle (vert, rouge)."""
    vert, rouge = cycle
    periode = vert + rouge
    t_mod = t % periode
    if t_mod < vert:
        return 0  # vert
    else:
        return periode - t_mod  # attente jusqu'au prochain vert

def creer_ville(nb_noeuds, proba_route=0.3):
    """Crée une ville simple avec des routes et des feux rouges."""
    G = nx.DiGraph()
    cycles = {}
    for i in range(nb_noeuds):
        # chaque noeud a un cycle aléatoire vert/rouge
        cycles[i] = (random.randint(5, 15), random.randint(10, 30))
        G.add_node(i)
        cycles[i] = (random.randint(5, 15), random.randint(10, 30))# possibilité de modifier le random des cycles 
        G.add_node(i)
        #cree les routes 
        for u in range(nb_noeuds):
            for v in range(nb_noeuds):
                if u != v and random.random() < proba_route:
                   G.add_edge(u, v, weight=random.randint(1, 10) #mettre le poids des feux)
        return G,cycle

def dijkstra_dynamique(G, cycles, depart, arrivee):
    """Dijkstra qui tient compte du temps d’attente aux feux rouges."""
    file = [(0, depart, [depart])]
    vus = {}
    while file:
        temps, noeud, chemin = heapq.heappop(file)
        if noeud == arrivee:
            return temps, chemin
        if noeud in vus and vus[noeud] <= temps:
            continue
        vus[noeud] = temps
        for voisin in G.successors(noeud):
            poids = G[noeud][voisin]["weight"]
            t_arr = temps + poids
            attente = temps_attente(cycles[voisin], t_arr)
            nouveau_temps = t_arr + attente
            heapq.heappush(file, (nouveau_temps, voisin, chemin + [voisin]))
    return float("inf"), []
