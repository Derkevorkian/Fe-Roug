import networkx as nx 
import heapq
import random
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import math
import numpy as np


def wrap(i, t, Nrep):
    return i * Nrep + t

def attente(i, t):
    return 99

def aux1(t):
    return 5 + t

def aux2(t):
    return 10 - t

def dupliquergraphe(Matrice, Nrep):
    G = nx.DiGraph()
    M_len = len(Matrice)

    #  Ajout des nœuds
    for i in range(M_len):
        for t in range(Nrep):
            G.add_node(wrap(i, t, Nrep))

    #  Ajout des arêtes de déplacement (i -> j)
    for i in range(M_len):
        for j in range(M_len):
            w = Matrice[i][j]

            # On ignore les diagonales et les poids None
            if w is not None and i != j:

                for t in range(Nrep):
                    if callable(w):
                        poids = w(t)
                    else:
                        poids = w

                    # pas d'arête si poids 0
                    if poids != 0:
                        G.add_edge(
                            wrap(i, t, Nrep),
                            wrap(j, (t + 1) % Nrep, Nrep),
                            weight=poids
                        )

    #   Ajout des arêtes d'attente (i -> i)
    for i in range(M_len):
        for t in range(Nrep):
            poids_attente = attente(i, t)

            # pas d'arête si poids 0
            if poids_attente != 0:
                G.add_edge(
                    wrap(i, t, Nrep),
                    wrap(i, (t + 1) % Nrep, Nrep),
                    weight=poids_attente
                )

    # AFFICHAGE
    plt.figure(figsize=(10, 8))
    pos = nx.spring_layout(G, seed=42, k=0.9)

    # Dessin des nœuds
    nx.draw_networkx_nodes(G, pos, node_color='lightgreen', node_size=800)
    nx.draw_networkx_labels(G, pos, font_size=12, font_weight='bold')

    # Dessin des arêtes
    nx.draw_networkx_edges(G, pos, arrows=True)

    # Dessin des poids
    edge_labels = nx.get_edge_attributes(G, 'weight')
    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels)

    plt.title("Graphe dédynamisé")
    plt.axis('off')
    plt.show()

    return G


M = [
    [0,           lambda t: aux1(t) ,       0],
    [0,           0,                    lambda t: aux2(t)],
    [3,           0,                    0]
]
G = dupliquergraphe(M, Nrep=4)




"""

def temps_attente(cycle, t):
    ""Calcule le temps d'attente au feu selon l'heure t et son cycle (vert, rouge).""
    vert, rouge = cycle
    periode = vert + rouge
    t_mod = t % periode
    if t_mod < vert:
        return 0  # vert
    else:
        return periode - t_mod  # attente jusqu'au prochain vert

def creer_ville(nb_noeuds, proba_route=0.3):
    ""Crée une ville simple avec des routes et des feux rouges.""
    G = nx.DiGraph()
    cycles = {}
    for i in range(nb_noeuds):
        # chaque noeud a un cycle aléatoire vert/rouge
        cycles[i] = (random.randint(5, 15), random.randint(10, 30))
        G.add_node(i)

    # ajouter des routes aléatoires
    for u in range(nb_noeuds):
        for v in range(nb_noeuds):
            if u != v and random.random() < proba_route:
                G.add_edge(u, v, weight=random.randint(1, 10))
    return G, cycles

def dijkstra(graphe, depart):
    # Distances connues (au départ, infini sauf départ = 0)
    inf = 999999
    distances = {}
    for sommet in graphe :
             distances[sommet] = inf
    distances[depart] = 0

    # Sommets visités
    visites = []

    while len(visites) < len(graphe):
        # On choisit le sommet non visité avec la plus petite distance
        non_visites = [s for s in graphe if s not in visites]
        sommet_courant = non_visites[0]
        for sommet in non_visites:
            if distances[sommet] < distances[sommet_courant]:
                sommet_courant = sommet

        # On met à jour les distances de ses voisins
        for voisin in graphe[sommet_courant]:
            nouvelle_distance = distances[sommet_courant] + graphe[sommet_courant][voisin]
            if nouvelle_distance < distances[voisin]:
                distances[voisin] = nouvelle_distance

        # On marque le sommet comme visité
        visites.append(sommet_courant)

    return distances
    
"""
