import networkx as nx
import heapq
import random
import matplotlib.pyplot as plt
import matplotlib.animation as animation

def temps_attente(cycle, t):
    """Calcule le temps d'attente au feu selon l'heure t et son cycle (vert, rouge)."""
    vert, rouge = cycle
    periode = vert + rouge
    t_mod = t % periode
    if t_mod < vert:
        return 0  # vert
    else:
        return periode - t_mod  # attente jusqu'au prochain vert

def creer_ville(nb_noeuds, proba_route=0.3):
    """Crée une ville simple avec des routes et des feux rouges."""
    G = nx.DiGraph()
    cycles = {}
    for i in range(nb_noeuds):
        # chaque noeud a un cycle aléatoire vert/rouge
        cycles[i] = (random.randint(5, 15), random.randint(10, 30))
        G.add_node(i)

    # ajouter des routes aléatoires
    for u in range(nb_noeuds):
        for v in range(nb_noeuds):
            if u != v and random.random() < proba_route:
                G.add_edge(u, v, weight=random.randint(1, 10))
    return G, cycles




import matplotlib.pyplot as plt
import networkx as nx

def dupliquer_et_afficher(adj, n):
    """
    Duplique un graphe représenté par une matrice d’adjacence
    et affiche les copies empilées verticalement.

    - adj : matrice d’adjacence (liste de listes)
    - n : nombre de duplications (le graphe final aura n+1 couches)
    """

    # Étape 1 : paramètres de base
    m = len(adj)        # nombre de noeuds par couche
    L = n + 1           # nombre total de couches (graphe original + duplications)
    M = m * L           # taille totale du graphe final

    # Étape 2 : créer la nouvelle matrice d’adjacence
    nouvelle = [[0 for _ in range(M)] for _ in range(M)]

    # Copie du graphe original dans chaque couche
    for couche in range(L):
        offset = couche * m
        for i in range(m):
            for j in range(m):
                if adj[i][j] != 0:
                    nouvelle[offset + i][offset + j] = 1

    # Relier les couches successives (chaque noeud vers sa copie en dessous)
    for couche in range(L - 1):
        off1 = couche * m
        off2 = (couche + 1) * m
        for i in range(m):
            nouvelle[off1 + i][off2 + i] = 1

    # Étape 3 : construire le graphe NetworkX
    G = nx.DiGraph()
    for i in range(M):
        for j in range(M):
            if nouvelle[i][j] != 0:
                G.add_edge(i, j)


    # Étape 4 : calcul des positions pour affichage vertical
    pos = {}
    ecart_vertical = 5
    ecart_horizontal = 2

    for couche in range(L):
        for i in range(m):
            noeud = couche * m + i
            pos[noeud] = (i * ecart_horizontal, -couche * ecart_vertical)

    # Étape 5 : affichage
    plt.figure(figsize=(8, 6))
    nx.draw(
        G, pos,
        with_labels=True,
        node_color="skyblue",
        node_size=700,
        edgecolors="black",
        arrowsize=15,
        font_weight="bold"
    )
    plt.title(f"Graphe dupliqué verticalement ({L} couches)")
    plt.axis("off")
    plt.show()

    # on renvoie la matrice dupliquée si on veut la réutiliser
    return nouvelle
