import networkx as nx 
import heapq
import random
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import math
import numpy as np


def moduler(Matrice, Nrep):
    poids = []
    for t in range(Nrep):
        liste = []
        for i in range(len(Matrice)):
            k = i*Nrep + t
            liste.append(k)
        poids.append(liste)
    return poids

def wrap(i, t, Nrep):
    return i*Nrep + t

def unwrap(k, N):
    return (t//N, t%n)


def attente(i, t):
    # Temps passé à attendre en restant sur place;une seconde d'attente par défaut
    return 1

def dupliquergraphe(Matrice, Nrep):
    poids = moduler(Matrice, Nrep)
    G = nx.DiGraph()
    M = len(Matrice)

    # Ajout des nœuds (i, t)
    for i in range(M):
        for t in range(Nrep):
            G.add_node(wrap(i, t, Nrep))

    # Ajout des arêtes inter-sommets (déplacements)
    for i in range(M):
        for j in range(M):
            w = Matrice[i][j]
            if w is not None:           # un arc existe
                for t in range(Nrep):

                    if callable(w):
                        poids = w(t)    # calcule le poids en fonction du temps t
                    else:
                        poids = w       # poids constant
                        
                    G.add_edge(
                        wrap(i, t, Nrep),
                        wrap(j, (t + 1) % Nrep, Nrep),
                        weight=poids)


# faire du sur place 
    for i in range(M):
        for t in range(Nrep):
            G.add_edge(
                wrap(i, t, Nrep),
                wrap(i, (t + 1) % Nrep, Nrep),
                weight=attente(i, t)     # attente de 1 sec 
            )


    # Affichage
    pos = nx.spring_layout(G, seed=42)
    nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=800)
    edge_labels = nx.get_edge_attributes(G, 'weight')
    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels)
    plt.show()

    return G


M = [
    [0,           lambda t: 5 + t,       0],
    [0,           0,                    lambda t: 10 - t],
    [3,           0,                    0]
]

G = dupliquergraphe(M, Nrep=4)


"""

def temps_attente(cycle, t):
    ""Calcule le temps d'attente au feu selon l'heure t et son cycle (vert, rouge).""
    vert, rouge = cycle
    periode = vert + rouge
    t_mod = t % periode
    if t_mod < vert:
        return 0  # vert
    else:
        return periode - t_mod  # attente jusqu'au prochain vert

def creer_ville(nb_noeuds, proba_route=0.3):
    ""Crée une ville simple avec des routes et des feux rouges.""
    G = nx.DiGraph()
    cycles = {}
    for i in range(nb_noeuds):
        # chaque noeud a un cycle aléatoire vert/rouge
        cycles[i] = (random.randint(5, 15), random.randint(10, 30))
        G.add_node(i)

    # ajouter des routes aléatoires
    for u in range(nb_noeuds):
        for v in range(nb_noeuds):
            if u != v and random.random() < proba_route:
                G.add_edge(u, v, weight=random.randint(1, 10))
    return G, cycles

def dijkstra(graphe, depart):
    # Distances connues (au départ, infini sauf départ = 0)
    inf = 999999
    distances = {}
    for sommet in graphe :
             distances[sommet] = inf
    distances[depart] = 0

    # Sommets visités
    visites = []

    while len(visites) < len(graphe):
        # On choisit le sommet non visité avec la plus petite distance
        non_visites = [s for s in graphe if s not in visites]
        sommet_courant = non_visites[0]
        for sommet in non_visites:
            if distances[sommet] < distances[sommet_courant]:
                sommet_courant = sommet

        # On met à jour les distances de ses voisins
        for voisin in graphe[sommet_courant]:
            nouvelle_distance = distances[sommet_courant] + graphe[sommet_courant][voisin]
            if nouvelle_distance < distances[voisin]:
                distances[voisin] = nouvelle_distance

        # On marque le sommet comme visité
        visites.append(sommet_courant)

    return distances
    
"""
