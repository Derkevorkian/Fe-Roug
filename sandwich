import networkx as nx
import random
import matplotlib.pyplot as plt



def temps_attente(cycle, t):
    """Calcule le temps d'attente au feu selon l'heure t et son cycle (vert, rouge)."""
    vert, rouge = cycle
    periode = vert + rouge
    t_mod = t % periode
    if t_mod < vert:
        return 0  # vert
    else:
        return periode - t_mod  # rouge

def creer_ville(nb_noeuds, proba_route=0.4):
    """Crée une ville simple avec des routes et des feux rouges."""
    G = nx.DiGraph()
    cycles = {}

    # Création des noeuds et des cycles de feux
    for i in range(nb_noeuds):
        # (temps_vert, temps_rouge) aléatoires
        cycles[i] = (random.randint(5, 10), random.randint(5, 10))
        G.add_node(i)

    # Création des routes
    for u in range(nb_noeuds):
        for v in range(nb_noeuds):
            if u != v and random.random() < proba_route:
                # Le poids est le temps de trajet sur la route (sans compter le feu)
                G.add_edge(u, v, weight=random.randint(2, 5))
    return G, cycles


def wrap(i, t, Nrep):
    return i * Nrep + t

def unwrap(k, Nrep):
    return (k // Nrep, k % Nrep)

def dedynamiser_ville(G_ville, cycles, Nrep):
    """
    Transforme le graphe dynamique de la ville en un grand graphe statique espace-temps.
    Chaque arête prend en compte le trajet + l'attente au feu à l'arrivée.
    """
    G_big = nx.DiGraph()

    # creation des noeuds
    for u in G_ville.nodes():
        for t in range(Nrep):
            G_big.add_node(wrap(u, t, Nrep))

    # création des arêtes
    for u, v, data in G_ville.edges(data=True):
        w_route = data['weight']

        for t in range(Nrep):
            # Calcul du moment d'arrivée au feu
            t_arrivee_feu = t + w_route

            # Calcul de l'attente nécessaire au noeud v à ce moment là
            # Attention: Si on dépasse Nrep, le calcul du cycle reste valide (t est absolu pour le cycle)
            wait = temps_attente(cycles[v], t_arrivee_feu)

            cout_total = w_route + wait
            t_final = t + cout_total

            # On ne crée l'arête que si on ne sort pas de l'horizon temporel Nrep
            if t_final < Nrep:
                source = wrap(u, t, Nrep)
                dest = wrap(v, t_final, Nrep)

                G_big.add_edge(source, dest, weight=cout_total)

    return G_big

def tous_les_dijkstras(G_big, nb_noeuds, Nrep):
    """
    Lance Dijkstra depuis chaque ville (à t=0).
    Renvoie une liste de tuples : (ville_depart, longueurs, chemins)
    """
    liste_resultats = []

    for i in range(nb_noeuds):
        # Point de départ : ville i au temps 0
        depart_node = wrap(i, 0, Nrep)

        # On vérifie si le noeud existe
        if depart_node in G_big:
            # Calcule tous les chemins depuis ce départ
            longueurs, chemins = nx.single_source_dijkstra(G_big, depart_node)

            # On stocke le résultat
            liste_resultats.append((i, longueurs, chemins))

    return liste_resultats



def trouver_chemin_A_vers_B(liste_resultats, ville_A, ville_B, Nrep):
    """
    Cherche dans la liste des résultats le meilleur chemin allant
    SPECIFIQUEMENT de ville_A vers ville_B.
    """
    # 1. On récupère le résultat Dijkstra qui part de ville_A
    longueurs_A = None
    chemins_A = None

    for depart, dict_longueurs, dict_chemins in liste_resultats:
        if depart == ville_A:
            longueurs_A = dict_longueurs
            chemins_A = dict_chemins
            break

    if longueurs_A is None:
        return float('inf'), []

    # 2. On cherche la meilleure arrivée à ville_B (quel que soit le temps t)
    min_temps = float('inf')
    meilleur_chemin = []

    for t in range(Nrep):
        cible = wrap(ville_B, t, Nrep)
        # Si cette cible est atteinte
        if cible in longueurs_A:
            if longueurs_A[cible] < min_temps:
                min_temps = longueurs_A[cible]
                meilleur_chemin = chemins_A[cible]

    return min_temps, meilleur_chemin

# Animation dynamique
def anime_ville(G, cycles, duree=50):
    pos = nx.spring_layout(G, seed=42)

    fig, ax = plt.subplots(figsize=(6, 6)) #taille 6*6

    def update(t): #temps courant
        ax.clear() #enleve le graphe précedent
        couleurs = []
        labels = {}
        for n in G.nodes():
            cycle = cycles[n]
            attente = temps_attente(cycle, t) #check les cycles
            if attente == 0:
                couleurs.append("green")
            else:
                couleurs.append("red")
            labels[n] = f"{n}\n({cycle[0]},{cycle[1]})" #dessine la couleur et le cycle
        nx.draw(G, pos, ax=ax, with_labels=True, node_color=couleurs,
                labels=labels, node_size=1000, font_color="white")
        nx.draw_networkx_edge_labels(G, pos, edge_labels=nx.get_edge_attributes(G, "weight"))
        ax.set_title(f"Temps = {t}")

    ani = animation.FuncAnimation(fig, update, frames=duree, interval=500, repeat=False)
    plt.show()



# Paramètres
NB_NOEUDS = 5
HORIZON = 60
A = 0
B = 4

# Calculs
G_ville, cycles = creer_ville(NB_NOEUDS) #Digraphe, dico
G_big = dedynamiser_ville(G_ville, cycles, HORIZON)
tous_res = tous_les_dijkstras(G_big, NB_NOEUDS, HORIZON)


# Résultat
temps, chemin = trouver_chemin_A_vers_B(tous_res, A, B, HORIZON)

print(f"Trajet de {A} vers {B} :")
if temps == float('inf'):
    print("Impossible d'atteindre la destination.")
else:
    print(f"Temps minimum : {temps} secondes")
    # Affichage des étapes (décodage des noeuds)
    etapes = [f"{unwrap(k, HORIZON)[0]}(t={unwrap(k, HORIZON)[1]})" for k in chemin]
    print(" -> ".join(etapes))


anime_ville(G_ville, cycles, duree=40)
